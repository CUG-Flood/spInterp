% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/anusplin.R
\name{anusplin_make_param}
\alias{anusplin_make_param}
\title{Create configures for ANUSPLIN}
\usage{
anusplin_make_param(
  dat,
  basename,
  range,
  res = 0.25,
  order = 3L,
  unit = 0L,
  width = 9,
  missing = -9999L,
  file.alt = NULL,
  alt = c("cov", "spl"),
  type.alt = "arcinfo_grid",
  type.grd = "xyz",
  type.mask = "none",
  file.mask = NULL,
  cvt.lon = c(0, 5),
  cvt.lat = c(0, 5),
  cvt.alt = c(1, 1),
  cvt.coef = 1000,
  trans.dep = 0,
  err.wgt = 0,
  optimize = 1,
  smooth = 1,
  ...,
  err.cov = 2,
  grid.pos = 1,
  essential = TRUE
)
}
\arguments{
\item{dat}{A data.frame or data.table to interpolate, for the colnames, lon,
lat must be included, site and alt are optional, the others are variable names.}

\item{basename}{Basename for all output files, extensions should not be included.}

\item{range}{Range of interpolation grid (xmin, xmax, ymin, ymax).}

\item{res}{The grid resolution (degree).}

\item{order}{(default 3L), order of spline, a positive integer.}

\item{unit}{The unit of \code{dat}, a non-negative integer, possible values are:
\itemize{
\item \code{0}: undefined (\strong{default})
\item \code{1}: meteres
\item \code{2}: feet
\item \code{3}: kilometers
\item \code{4}: miles
\item \code{5}: degrees
\item \code{6}: radians
\item \code{7}: millimetres
\item \code{8}: megajoules
}}

\item{width}{The fixed width of numbers in formatted data.}

\item{missing}{Filling of missing values.}

\item{file.alt}{file path of alt
\itemize{
\item \code{type.alt != "none"}: file.alt is file path
\item \code{type.alt == "none"}: file.alt is a const real number
}}

\item{alt}{Type of elevation was treated, possible values are:
\itemize{
\item \code{cov}  : considered as independent covariates (\strong{default})
\item \code{spl}  : considered as independent spline variables
}}

\item{type.alt}{type of grid, one of \code{c("const", "generic_grid", "arcinfo_grid", "idrisi_img")},
default \code{arcinfo_grid}}

\item{type.grd}{type of grid, one of \code{c("xyz", "generic_grid", "arcinfo_grid", "idrisi_img")},
default \code{arcinfo_grid}}

\item{type.mask}{type of \code{file.mask}, one of c("none", "generic_grid",
"arcinfo_grid", "idrisi_img")\verb{, default }arcinfo_grid`.}

\item{file.mask}{Filename of mask grid, only valid if \code{type.mask} set to positive
integer.}

\item{cvt.lon}{Transformation and scale factor (\strong{default} is \code{1}) of longitude.\cr
Real Value = (Table Value) * (Scale Factor)\cr

The possible transformations are:
\itemize{
\item \code{0}: no transformation (\strong{default})
\item \code{1}: x/a
\item \code{2}: ax
\item \code{3}: a·log(x+b)
\item \code{4}: (x/b)^a
\item \code{5}: a·exp(x/b)
\item \code{6}: a·tanh(x/b)
\item \code{7}: anisotropy angle in degrees
\item \code{8}: anisotropy factor - in the direction specified by the anisotropy angle
}}

\item{cvt.lat}{Same as \code{cvt.lon}, but for latitude.}

\item{cvt.alt}{Same as \code{cvt.lon}, but for altitude.}

\item{cvt.coef}{Parameters used for transformation, one or two real numbers.}

\item{trans.dep}{Dependent variable transformation, possible values are:
\itemize{
\item \code{0}: no transformation (\strong{default})
\item \code{1}: fit surface to natural logarithm of the data values
\item \code{2}: fit surface to the square root of the data values
\item \code{5}: occurrence – transform data values by setting all positive value to 1.0 and ignoring all negative values
}}

\item{err.wgt}{Number of relative error variances, a non-negative integer,
possible values are:
\itemize{
\item \code{0}: data points uniformly weighted for each surface (\strong{default})
\item \code{1}: the same weighting is applied to each surface
\item \verb{Number of surfaces}: a different weighting is applied to each surface
}}

\item{optimize}{Optimization directive, a non-negative integer, possible values are:
\itemize{
\item \code{0}: common smoothing parameter for all surfaces
\item \code{1}: common smoothing directive for all surfaces (\strong{default})
\item \code{2}: different smoothing directive for each surface
}}

\item{smooth}{Smoothing directive for each surface, a non-negative integer,
possible values are:
\itemize{
\item \code{0}: fixed smoothing parameter - supply value
\item \code{1}:  minimise GCV (\strong{default})
\item \code{2}: minimise true mean square error using supplied error standard deviation estimate
\item \code{3}: fixed signal - supply value
\item \code{4}: minimise GML
}}

\item{...}{ignored.}

\item{err.cov}{test}

\item{grid.pos}{Grid position option, a non-negative integer, possible values are:
\itemize{
\item \code{0}: grid points at cell corners
\item \code{1}: grid points at cell centres (\strong{default})
}}

\item{essential}{If \code{True}, only export essential process files, large residual
file, optimisation parameters file, data list file and validation data file are
ignored.}

\item{lim.lon}{A vector containing lower and upper limits, \code{auto} (default)
meant to use the minimum and maximum values in the data, or set manually.
Data points outside these limits, augmented by margins, are ignored.}

\item{lim.lat}{Same as \code{lim.lon}, but for longitude.}

\item{lim.alt}{Same as \code{lim.lon}, but for altitude.}
}
\value{
a list with three components:
\itemize{
\item \code{data}   : formatted data.table of \code{dat}
\item \code{splina} : a vector containing splina parameters
\item \code{lapgrd} : a vector containing lapgrd parameters
}
}
\description{
Format the input data and generate the configuration file required for ANUSPLIN interpolation.
}
\section{grid_type}{

\itemize{
\item \code{none}         : not provided
\item \code{xyz}          : grid written in X,Y,Z format
\item \code{generic_grid} : generic grid written by rows
\item \code{arcinfo_grid} : Arc/Info grid
\item \code{idrisi_img}   : Idrisi image
}
}

\examples{
\dontrun{
dat <- dat_RH[, .(lon, lat, alt, RH)]
X <- dat[, .(lon, lat, alt)] \%>\% as.matrix()
Y <- dat[, .(RH)] \%>\% as.matrix()

res <- 1
range <- c(70, 140, 15, 55)
r_dem <- get_chinadem(res = res) \%>\% round(1)
f_dem <- "output/dem.asc"
write_dem(r_dem, f_dem, digits = 1)

outdir <- "output"

anusplin_make_param(dat, "RH", range, res, file.alt = f_dem, cvt.coef = 1e3) -> param
anusplin_write_setting(param, outdir, is.run = TRUE, overwrite = TRUE)
anusplin_read_output(param$lapgrd, outdir) -> ans

ans
}
}
