% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spInterp_Tps.R
\name{spInterp_Tps}
\alias{spInterp_Tps}
\title{Thin plate spline regression}
\usage{
spInterp_Tps(
  points,
  dat,
  range,
  res = 1,
  Z = NULL,
  ZGrid = NULL,
  .parallel = FALSE,
  ...,
  weight = NULL
)
}
\arguments{
\item{Z}{The covariates for the grid unrolled as a matrix. Columns index
the variables and rows index the grid locations. E.g. For
 evaluation on  a 10X15 grid and with 2 covariates. \code{ dim( ZGrid) == c(10,15, 2)}.  and so \code{  dim( Z) = c(150, 2)} and  
 \code{ Z[,1] <- c( ZGrid[,,1])}
 }

\item{ZGrid}{An array  or list form of covariates to use for
	 prediction. This must match the same dimensions from the 
\code{grid.list} / \code{gridList} argument.  

If ZGrid is an array then the first two indices are the x and y
 locations in the 
grid. The third index, if present, indexes the covariates. e.g. For
 evaluation on 
a 10X15 grid and with 2 covariates. \code{ dim( ZGrid) == c(10,15, 2)}.
If ZGrid is a list then the components x and y shold match those of grid list and
the z component follows the shape described above for the no list 
case. 
}

\item{...}{others to \code{\link[fields:Tps]{fields::Tps()}}}
}
\description{
Thin plate spline regression
}
\examples{
## `spInterp_Tps` example -------------------------
dat <- dat_RH[, .(lon, lat, alt, RH)]
X <- dat[, .(lon, lat)] \%>\% as.matrix()
Y <- dat[, .(RH)] \%>\% as.matrix()
Z <- dat[, .(alt)] \%>\% as.matrix()

range <- c(70, 140, 15, 55)
res = 2 # resolution

# prepare dems
r_dem <- get_chinadem(res = res)
ZGrid <- rast2zgrid(r_dem)$ZGrid # a 3d array
image.plot(ZGrid[,,1]) # should looks normal

r = spInterp_Tps(X, Y, range, res = res, Z = Z, ZGrid = ZGrid)
print(r)
plot(r)

# with dem
kford_ml(X, Y, FUN = spInterp_Tps, 
  range = range, res = res, Z = Z, ZGrid = ZGrid)

# without dem
kford_ml(X, Y, FUN = spInterp_Tps, 
  range = range, res = res, Z = NULL, ZGrid = ZGrid)
}
